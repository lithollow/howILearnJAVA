## 一、javac

首先，我们有一个扩展名为.java的源文件，其中包含Java代码

编译：使用编译器（javac）将源文件编译成字节码文件（.class文件）

	1. 语法分析
	2. 语义分析
	3. 生成字节码：编译器将源代码翻译成字节码，并保存为.class文件。

字节码是一种中间代码，它不依赖于特定的硬件和操作系统，运行在Java虚拟机上



## 二、JVM

### 1、Loading 加载

1. 通过类的全名，从不同的数据源（可能是 class 文件、也可能是 jar 包，甚至网络）获取类的二进制字节流，加载到**内存**

2. 解析类的二进制数据流为方法区内的数据结构（Java类模型）

3. 在**堆**生成一个代表该类的 `java.lang.Class` 对象，作为方法区这个类的各种数据的访问入口



### 2、Linking 链接

##### 2.1、Verification 验证

对二进制字节流进行校验，只有符合 JVM 字节码规范的才能被 JVM 正确执行

主要检查：

- 确保二进制字节流格式符合预期（魔数 `cafe babe` 、版本、长度...
  - 和加载阶段一起执行，验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区
  - 格式验证之外的验证操作将会在方法区中进行
- 语义：是否继承final，是否有父类，抽象方法是否有实现...
- 字节码：跳转指令指向是否正确，方法调用的参数是否正确...
- 符号的直接引用是否存在
- ……



##### 2.2、Perparation 准备

对类变量（`static`修饰的）分配内存并初始化（对应数据类型的默认初始值

```
public String str1 = "abc";					// 不会被分配内存
public static String str2 = "abc";			// 分配内存，初始值为 null 而非 "abc"
public static final String str3 = "abc";	// static final 修饰的常量在编译的时候就分配了，在准备阶段的值为"abc"
```



##### 2.3、Resolution 解析

将常量池中的符号引用转化为直接引用

​	符号引用 → 像"我要找OtherClass类的VALUE字段"这样的描述

​	直接引用 → 像"在内存地址0x1234处的第8个字节"这样的具体位置

JVM为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法

通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用



### 3、Initialization 初始化



### 4、Using 使用



### 5、Unloading 卸载

当Sample类被加载、链接和初始化后，它的生命周期就开始了。

当代表Sample类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而结束Sample类的生命周期。

一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。