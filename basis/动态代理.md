## 一、静态代理

```java
public class Calculator {
	// 加
	public int add(int a, int b) {
		int result = a + b;
		return result;
	}
	// 减
	public int subtract(int a, int b) {
		int result = a - b;
		return result;
	}
	// 乘法、除法...
}
```

需求：给这个计算器的原有方法添加日志打印

使用静态代理：

- 将Calculator抽取为接口

  ```java
  // Calculator接口
  public interface Calculator {
  	int add(int a, int b);
  	int subtract(int a, int b);
  }
  ```

- 创建目标类CalculatorImpl实现Calculator

  ```java
  // 目标类
  public class CalculatorImpl implements Calculator {
  	// 加
  	public int add(int a, int b) {
  		int result = a + b;
  		return result;
  	}
  	// 减
  	public int subtract(int a, int b) {
  		int result = a - b;
  		return result;
  	}
  }
  ```

- 创建代理类CalculatorProxy实现Calculator

  ```java
  // 静态代理类
  public class CalculatorProxy implements Calculator {
      // 代理对象内部维护一个目标对象引用
  	private Calculator target;
          
      // 通过构造方法，传入目标对象
  	public CalculatorProxy(Calculator target) {
  		this.target = target;
  	}
  
      // 调用目标对象的add，并在前后打印日志
  	@Override
  	public int add(int a, int b) {
  		System.out.println("add方法开始...");
  		int result = target.add(a, b);
  		System.out.println("add方法结束...");
  		return result;
  	}
      // 调用目标对象的subtract，并在前后打印日志
  	@Override
  	public int subtract(int a, int b) {
  		System.out.println("subtract方法开始...");
  		int result = target.subtract(a, b);
  		System.out.println("subtract方法结束...");
  		return result;
  	}
  }
  ```

优点：可以在不修改目标对象的前提下，对目标对象进行功能的扩展和拦截。

符合开闭原则：对扩展开放，对修改关闭

日志打印硬编码独立于代理类，利于后期维护

问题：代理类CalculatorProxy只能给Calculator做代理，它们绑定死了。存在重复代码：要给其他类也添加日志打印功能，就得为其他几百个接口都各自写一份代理类。



---



## 二、动态代理

- 自动生成代理对象，不用编写代理类
- 将增强代码与代理类（代理对象）解耦，从而达到代码复用

```java
public static void main(String[] args) throws Exception {
    /*
    * 参数1：类加载器，随便给一个
    * 参数2：需要生成代理Class的接口，比如Calculator
    * */
    Class<?> calculatorProxyClazz = Proxy.getProxyClass(Calculator.class.getClassLoader(),Calculator.class);
    // 得到唯一的有参构造 $Proxy(InvocationHandler h)，和反射的Method有点像，可以理解为得到对应的构造器执行器
    Constructor<?> constructor = calculatorProxyClazz.getConstructor(InvocationHandler.class);
    // 用构造器执行器执行构造方法，得到代理对象。构造器需要InvocationHandler入参
    Calculator calculatorProxyImpl = (Calculator)constructor.newInstance(new InvocationHandler() {
    		/* 
    		* invoke()方法的参数:
    		* Object proxy：代理对象本身，而不是目标对象（不要调用，会无限递归
    		* method：方法执行器，用来执行方法（传入目标对象就执行目标对象的方法
    		* args：方法参数
    		* */
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                // 手动new一个目标对象
                CalculatorImpl calculatorImpl = new CalculatorImpl();
                // 执行方法前打印日志
                System.out.println(method.getName() + "方法开始执行...");
                // 反射执行目标对象方法
                Object result = method.invoke(calculatorImpl, args);
                // 执行方法后打印日志
                System.out.println(result);
                System.out.println(method.getName() + "方法执行结束...");
                // 返回目标对象的执行结果
                return result;
            }
        });
        calculatorProxyImpl.add(1, 2);
    }
}
```

优化1：抽取方法

```java
public class ProxyTest {
    public static void main(String[] args) throws Throwable {
        CalculatorImpl target = new CalculatorImpl();
        // 传入目标对象
        Calculator calculatorProxy = (Calculator) getProxy(target);
        calculatorProxy.add(1, 2);
    }

    /**
     * 传入目标对象，获取代理对象
     * @param target
     * @return
     * @throws Exception
     */
    private static Object getProxy(final Object target) throws Exception {
        Class<?> proxyClazz = Proxy.getProxyClass(target.getClass().getClassLoader(), target.getClass().getInterfaces());
        Constructor<?> constructor = proxyClazz.getConstructor(InvocationHandler.class);
        return constructor.newInstance(new InvocationHandler() {
            @Override
            public Object invoke(Object proxy1, Method method, Object[] args) throws Throwable {
                System.out.println(method.getName() + "方法开始执行...");
                Object result = method.invoke(target, args);
                System.out.println(result);
                System.out.println(method.getName() + "方法执行结束...");
                return result;
            }
        });
    }
}
```

优化2：解耦增强代码和代理对象

```java
public class ProxyTest {
    public static void main(String[] args) throws Throwable {
        // 1.得到目标对象
        CalculatorImpl target = new CalculatorImpl();
        // 2.传入目标对象，得到增强对象（如果需要对目标对象进行别的增强，可以另外编写getXxInvocationHandler）
        InvocationHandler logInvocationHandler = getLogInvocationHandler(target);
        // 3.传入目标对象+增强代码，得到代理对象
        Calculator calculatorProxy = (Calculator) getProxy(target, logInvocationHandler);
        calculatorProxy.add(1, 2);
    }

    /**
     * 传入目标对象+增强代码，获取代理对象
     * @param target
     * @param handler
     * @return
     * @throws Exception
     */
    private static Object getProxy(final Object target, final InvocationHandler handler) throws Exception {
        // 参数1：随便找个类加载器给它 参数2：需要代理的接口
        Class<?> proxyClazz = Proxy.getProxyClass(target.getClass().getClassLoader(), target.getClass().getInterfaces());
        Constructor<?> constructor = proxyClazz.getConstructor(InvocationHandler.class);
        return constructor.newInstance(handler);
    }

    /**
     * 日志增强代码
     * @param target
     * @return
     */
    private static InvocationHandler getLogInvocationHandler(final CalculatorImpl target) {
        return new InvocationHandler() {
            @Override
            public Object invoke(Object proxy1, Method method, Object[] args) throws Throwable {
                System.out.println(method.getName() + "方法开始执行...");
                Object result = method.invoke(target, args);
                System.out.println(result);
                System.out.println(method.getName() + "方法执行结束...");
                return result;
            }
        };
    }
}
```

优化3：优化代码语义，`getProxy(target, invocationHandler)`的target参数是没必要的，`invocationHandler`已经包含目标对象

```java
public class ProxyTest {
    public static void main(String[] args) throws Throwable {
        // 1.得到目标对象
        CalculatorImpl target = new CalculatorImpl();
        // 2.传入目标对象，得到增强对象（如果需要对目标对象进行别的增强，可以另外编写getXxInvocationHandler）
        InvocationHandler logInvocationHandler = getLogInvocationHandler(target);
        // 3.传入接口+增强对象（含目标对象），得到代理对象
        Calculator calculatorProxy = (Calculator) getProxy(
                logInvocationHandler,                 // 增强对象（包含 目标对象 + 增强代码）
                target.getClass().getClassLoader(),   // 随便传入一个类加载器
                target.getClass().getInterfaces()     // 需要代理的接口
        );
        calculatorProxy.add(1, 2);
    }

    /**
     * 传入接口+增强（已经包含了目标对象），获取代理对象
     * @param handler
     * @param classLoader
     * @param interfaces
     * @return
     * @throws Exception
     */
    private static Object getProxy(final InvocationHandler handler, final ClassLoader classLoader, final Class<?>... interfaces) throws Exception {
        // 参数1：随便找个类加载器给它 参数2：需要代理的接口
        Class<?> proxyClazz = Proxy.getProxyClass(classLoader, interfaces);
        Constructor<?> constructor = proxyClazz.getConstructor(InvocationHandler.class);
        return constructor.newInstance(handler);
    }

    /**
     * 日志增强代码 同上
     */
    }
}
```

最终：

之前是把这三步封装为`getProxy()`方法

- 先获得`proxyClazz`
- 再根据`proxyClazz.getConstructor()`获取构造器
- 最后`constructor.newInstance()`生成代理对象

### JDK 动态代理

其实JDK已经提供了一步到位的方法`Proxy.newProxyInstance()`

```java
									public class ProxyTest {
    public static void main(String[] args) throws Throwable {
        // 1.得到目标对象
        CalculatorImpl target = new CalculatorImpl();
        // 2.传入目标对象，得到增强对象（如果需要对目标对象进行别的增强，可以另外编写getXxInvocationHandler）
        InvocationHandler logInvocationHandler = getLogInvocationHandler(target);
        // 3.传入目标对象+增强代码，得到代理对象（直接用JDK的方法）
        Calculator calculatorProxy = (Calculator) Proxy.newProxyInstance(
                target.getClass().getClassLoader(),   // 随便传入一个类加载器
                target.getClass().getInterfaces(),    // 需要代理的接口
                logInvocationHandler                  // 增强对象（包含 目标对象 + 增强代码）
        );
        calculatorProxy.add(1, 2);
    }

    /**
     * 日志增强代码 同上
     * getLogInvocationHandler 返回 InvocationHandler 重写 invoke()
     */
}
```



### CGLIB 动态代理

JDK 动态代理要求目标对象必须实现接口，而 CGLIB（Code Generation Library）动态代理无需目标对象实现接口，它通过生成目标类的子类来实现代理功能（**基于继承**）
Spring 框架中默认优先使用 JDK 动态代理，若目标类没有实现接口，则自动切换为 CGLIB 代理



基本原理：

- 通过字节码技术为目标类创建子类，并在子类中重写目标类的方法，在重写的方法中嵌入增强逻辑（如日志、事务等）
- 由于基于继承，目标类不能被`final`修饰（final 类无法被继承），目标类中的`final`方法也无法被代理（final 方法不能被重写）



```java
// 目标类（无接口）
public class Calculator {
    // 加
    public int add(int a, int b) {
        int result = a + b;
        return result;
    }
    // 减
    public int subtract(int a, int b) {
        int result = a - b;
        return result;
    }
}

// 创建方法拦截器（实现增强逻辑）
// 实现 CGLIB 的MethodInterceptor接口，重写intercept方法，该方法类似 JDK 动态代理的invoke方法，用于嵌入增强代码
public class LogMethodInterceptor implements MethodInterceptor {

    // 目标对象（被代理的原始对象）
    private Object target;

    public LogMethodInterceptor(Object target) {
        this.target = target;
    }

    /**
     * 拦截目标方法，执行增强逻辑
     * @param proxy 代理对象（子类对象）
     * @param method 目标方法
     * @param args 方法参数
     * @param methodProxy 方法代理对象（用于调用目标类的原始方法）
     * @return 目标方法的返回值
     */
    @Override
    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        // 增强逻辑：方法执行前打印日志
        System.out.println(method.getName() + "方法开始执行...");
        
        // 执行目标方法（通过methodProxy调用父类的原始方法，避免递归）
        Object result = methodProxy.invokeSuper(proxy, args);
        
        // 增强逻辑：方法执行后打印日志
        System.out.println("结果：" + result);
        System.out.println(method.getName() + "方法执行结束...");
        
        return result;
    }
}

// 通过 CGLIB 的Enhancer类生成目标类的子类（代理对象），并绑定方法拦截器
public class CglibProxyTest {
    public static void main(String[] args) {
        // 1. 创建目标对象
        Calculator target = new Calculator();
        
        // 2. 创建增强器（用于生成代理对象）
        Enhancer enhancer = new Enhancer();
        // 设置父类（目标类）
        enhancer.setSuperclass(Calculator.class);
        // 设置方法拦截器（包含增强逻辑和目标对象）
        enhancer.setCallback(new LogMethodInterceptor(target));
        
        // 3. 生成代理对象（目标类的子类）
        Calculator proxy = (Calculator) enhancer.create();
        // 调用有参构造创建代理：参数1=构造函数参数类型，参数2=构造函数参数值
        // TargetClass proxy = (TargetClass) enhancer.create(
        //     new Class[]{String.class}, // 构造函数参数类型：String
        //     new Object[]{"zhangsan"}   // 构造函数参数值：zhangsan
        // );
        
        // 4. 调用代理对象的方法（自动触发增强逻辑）
        proxy.add(1, 2);
        proxy.subtract(5, 3);
    }
}
```



CGLIB 与 JDK 动态代理的对比

| 特性                | JDK 动态代理                         | CGLIB 动态代理                     |
| ------------------- | ------------------------------------ | ---------------------------------- |
| 底层原理            | 基于接口实现（代理对象实现目标接口） | 基于继承实现（代理对象继承目标类） |
| 目标对象要求        | 必须实现接口                         | 可无接口（但不能是 final 类）      |
| 效率（创建 / 执行） | 创建快，执行稍慢                     | 创建慢（需生成子类字节码），执行快 |
| 方法限制            | 仅代理接口中的方法                   | 可代理所有非 final 方法            |

**Spring通过CGLIB创建的代理类，不会初始化代理类自身继承的任何成员变量，包括final类型的成员变量**！

