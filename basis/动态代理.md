## 一、静态代理

```
public class Calculator {
	// 加
	public int add(int a, int b) {
		int result = a + b;
		return result;
	}
	// 减
	public int subtract(int a, int b) {
		int result = a - b;
		return result;
	}
	// 乘法、除法...
}
```

需求：给这个计算器的原有方法添加日志打印

使用静态代理：

- 将Calculator抽取为接口

  ```
  // Calculator接口
  public interface Calculator {
  	int add(int a, int b);
  	int subtract(int a, int b);
  }
  ```

- 创建目标类CalculatorImpl实现Calculator

  ```
  // 目标类
  public class CalculatorImpl implements Calculator {
  	// 加
  	public int add(int a, int b) {
  		int result = a + b;
  		return result;
  	}
  	// 减
  	public int subtract(int a, int b) {
  		int result = a - b;
  		return result;
  	}
  }
  ```

- 创建代理类CalculatorProxy实现Calculator

  ```
  // 静态代理类
  public class CalculatorProxy implements Calculator {
      // 代理对象内部维护一个目标对象引用
  	private Calculator target;
          
      // 通过构造方法，传入目标对象
  	public CalculatorProxy(Calculator target) {
  		this.target = target;
  	}
  
      // 调用目标对象的add，并在前后打印日志
  	@Override
  	public int add(int a, int b) {
  		System.out.println("add方法开始...");
  		int result = target.add(a, b);
  		System.out.println("add方法结束...");
  		return result;
  	}
      // 调用目标对象的subtract，并在前后打印日志
  	@Override
  	public int subtract(int a, int b) {
  		System.out.println("subtract方法开始...");
  		int result = target.subtract(a, b);
  		System.out.println("subtract方法结束...");
  		return result;
  	}
  }
  ```

优点：可以在不修改目标对象的前提下，对目标对象进行功能的扩展和拦截。

符合开闭原则：对扩展开放，对修改关闭

日志打印硬编码独立于代理类，利于后期维护

问题：代理类CalculatorProxy只能给Calculator做代理，它们绑定死了。存在重复代码：要给其他类也添加日志打印功能，就得为其他几百个接口都各自写一份代理类。



---



## 二、动态代理

- 自动生成代理对象，不用编写代理类
- 将增强代码与代理类（代理对象）解耦，从而达到代码复用

```
public static void main(String[] args) throws Exception {
    /*
    * 参数1：类加载器，随便给一个
    * 参数2：需要生成代理Class的接口，比如Calculator
    * */
    Class<?> calculatorProxyClazz = Proxy.getProxyClass(Calculator.class.getClassLoader(),Calculator.class);
    // 得到唯一的有参构造 $Proxy(InvocationHandler h)，和反射的Method有点像，可以理解为得到对应的构造器执行器
    Constructor<?> constructor = calculatorProxyClazz.getConstructor(InvocationHandler.class);
    // 用构造器执行器执行构造方法，得到代理对象。构造器需要InvocationHandler入参
    Calculator calculatorProxyImpl = (Calculator)constructor.newInstance(new InvocationHandler() {
    		/* 
    		* invoke()方法的参数:
    		* Object proxy：代理对象本身，而不是目标对象（不要调用，会无限递归
    		* method：方法执行器，用来执行方法（传入目标对象就执行目标对象的方法
    		* args：方法参数
    		* */
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                // 手动new一个目标对象
                CalculatorImpl calculatorImpl = new CalculatorImpl();
                // 执行方法前打印日志
                System.out.println(method.getName() + "方法开始执行...");
                // 反射执行目标对象方法
                Object result = method.invoke(calculatorImpl, args);
                // 执行方法后打印日志
                System.out.println(result);
                System.out.println(method.getName() + "方法执行结束...");
                // 返回目标对象的执行结果
                return result;
            }
        });
        calculatorProxyImpl.add(1, 2);
    }
}
```

优化1：抽取方法

```
public class ProxyTest {
    public static void main(String[] args) throws Throwable {
        CalculatorImpl target = new CalculatorImpl();
        // 传入目标对象
        Calculator calculatorProxy = (Calculator) getProxy(target);
        calculatorProxy.add(1, 2);
    }

    /**
     * 传入目标对象，获取代理对象
     * @param target
     * @return
     * @throws Exception
     */
    private static Object getProxy(final Object target) throws Exception {
        Class<?> proxyClazz = Proxy.getProxyClass(target.getClass().getClassLoader(), target.getClass().getInterfaces());
        Constructor<?> constructor = proxyClazz.getConstructor(InvocationHandler.class);
        return constructor.newInstance(new InvocationHandler() {
            @Override
            public Object invoke(Object proxy1, Method method, Object[] args) throws Throwable {
                System.out.println(method.getName() + "方法开始执行...");
                Object result = method.invoke(target, args);
                System.out.println(result);
                System.out.println(method.getName() + "方法执行结束...");
                return result;
            }
        });
    }
}
```

优化2：解耦增强代码和代理对象

```
public class ProxyTest {
    public static void main(String[] args) throws Throwable {
        // 1.得到目标对象
        CalculatorImpl target = new CalculatorImpl();
        // 2.传入目标对象，得到增强对象（如果需要对目标对象进行别的增强，可以另外编写getXxInvocationHandler）
        InvocationHandler logInvocationHandler = getLogInvocationHandler(target);
        // 3.传入目标对象+增强代码，得到代理对象
        Calculator calculatorProxy = (Calculator) getProxy(target, logInvocationHandler);
        calculatorProxy.add(1, 2);
    }

    /**
     * 传入目标对象+增强代码，获取代理对象
     * @param target
     * @param handler
     * @return
     * @throws Exception
     */
    private static Object getProxy(final Object target, final InvocationHandler handler) throws Exception {
        // 参数1：随便找个类加载器给它 参数2：需要代理的接口
        Class<?> proxyClazz = Proxy.getProxyClass(target.getClass().getClassLoader(), target.getClass().getInterfaces());
        Constructor<?> constructor = proxyClazz.getConstructor(InvocationHandler.class);
        return constructor.newInstance(handler);
    }

    /**
     * 日志增强代码
     * @param target
     * @return
     */
    private static InvocationHandler getLogInvocationHandler(final CalculatorImpl target) {
        return new InvocationHandler() {
            @Override
            public Object invoke(Object proxy1, Method method, Object[] args) throws Throwable {
                System.out.println(method.getName() + "方法开始执行...");
                Object result = method.invoke(target, args);
                System.out.println(result);
                System.out.println(method.getName() + "方法执行结束...");
                return result;
            }
        };
    }
}
```

优化3：优化代码语义，`getProxy(target, invocationHandler)`的target参数是没必要的，`invocationHandler`已经包含目标对象

```
public class ProxyTest {
    public static void main(String[] args) throws Throwable {
        // 1.得到目标对象
        CalculatorImpl target = new CalculatorImpl();
        // 2.传入目标对象，得到增强对象（如果需要对目标对象进行别的增强，可以另外编写getXxInvocationHandler）
        InvocationHandler logInvocationHandler = getLogInvocationHandler(target);
        // 3.传入接口+增强对象（含目标对象），得到代理对象
        Calculator calculatorProxy = (Calculator) getProxy(
                logInvocationHandler,                 // 增强对象（包含 目标对象 + 增强代码）
                target.getClass().getClassLoader(),   // 随便传入一个类加载器
                target.getClass().getInterfaces()     // 需要代理的接口
        );
        calculatorProxy.add(1, 2);
    }

    /**
     * 传入接口+增强（已经包含了目标对象），获取代理对象
     * @param handler
     * @param classLoader
     * @param interfaces
     * @return
     * @throws Exception
     */
    private static Object getProxy(final InvocationHandler handler, final ClassLoader classLoader, final Class<?>... interfaces) throws Exception {
        // 参数1：随便找个类加载器给它 参数2：需要代理的接口
        Class<?> proxyClazz = Proxy.getProxyClass(classLoader, interfaces);
        Constructor<?> constructor = proxyClazz.getConstructor(InvocationHandler.class);
        return constructor.newInstance(handler);
    }

    /**
     * 日志增强代码 同上
     */
    }
}
```

最终：

之前是把这三步封装为`getProxy()`方法

- 先获得`proxyClazz`
- 再根据`proxyClazz.getConstructor()`获取构造器
- 最后`constructor.newInstance()`生成代理对象

其实JDK已经提供了一步到位的方法`Proxy.newProxyInstance()`

```
public class ProxyTest {
    public static void main(String[] args) throws Throwable {
        // 1.得到目标对象
        CalculatorImpl target = new CalculatorImpl();
        // 2.传入目标对象，得到增强对象（如果需要对目标对象进行别的增强，可以另外编写getXxInvocationHandler）
        InvocationHandler logInvocationHandler = getLogInvocationHandler(target);
        // 3.传入目标对象+增强代码，得到代理对象（直接用JDK的方法）
        Calculator calculatorProxy = (Calculator) Proxy.newProxyInstance(
                target.getClass().getClassLoader(),   // 随便传入一个类加载器
                target.getClass().getInterfaces(),    // 需要代理的接口
                logInvocationHandler                  // 增强对象（包含 目标对象 + 增强代码）
        );
        calculatorProxy.add(1, 2);
    }

    /**
     * 日志增强代码 同上
     */
}
```

